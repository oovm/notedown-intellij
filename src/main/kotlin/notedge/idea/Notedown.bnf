{
    parserClass = "notedge.idea.language.parser.NoteParser"
    parserUtilClass = "notedge.idea.language.psi.ParserExtension"

    extends = "notedge.idea.language.ast.NotedownASTBase"

    psiClassPrefix = "Note"
    psiImplClassSuffix = "Node"
    psiPackage = "notedge.idea.language.psi"
    psiImplPackage = "notedge.idea.language.psi_node"
    psiImplUtilClass = "notedge.idea.language.psi.NodeExtension"

    elementTypeHolderClass = "notedge.idea.language.psi.NoteTypes"
    elementTypeClass = "notedge.idea.language.psi.NElementType"
    tokenTypeClass = "notedge.idea.language.psi.NElementType"
    tokens = [
        NEW_LINE = 'NewLine'
        ESCAPE = '\'
        ACCENT = '^'
        EQ = '='
        COLON = ':'
        SEMICOLON = ';'
        COMMA = ','
        DOLLAR = '$'
        DOT = '.'
        STAR = '*'
        AT = '@'
    ]
}

Notedown ::= statement*;

private statement ::=
    header
  | text_elements
  | BREAK_PART
  ;
// ---------------------------------------------------------------------------------------------------------------------
header ::= HEADER_HASH text_elements {
    mixin = "notedge.idea.language.mixin.MixinHeader"
}
// ---------------------------------------------------------------------------------------------------------------------
text_elements ::= text_item+ {
    mixin = "notedge.idea.language.mixin.MixinTextElements"
}
private text_item ::= PLAIN_TEXT
  | function | xml_closed | xml_function
  | escaped | ESCAPE | NEW_LINE
  | italic | bold | strong
  | under | strike | wave
  | snippet | math
escaped ::= ESCAPED_CHARACTER
// ---------------------------------------------------------------------------------------------------------------------
italic ::= ITALIC_L [text_elements] ITALIC_R // *text*
bold   ::= BOLD_L   [text_elements] BOLD_R   // **text**
strong ::= STRONG_L [text_elements] STRONG_R // ***text***
// ---------------------------------------------------------------------------------------------------------------------
under  ::= UNDER_L  [text_elements] UNDER_R  // _text_
wave   ::= WAVE_L   [text_elements] WAVE_R   // __text__
strike ::= STRIKE_L [text_elements] STRIKE_R // ___text___
// ---------------------------------------------------------------------------------------------------------------------
snippet ::= CODE_L string? CODE_R {
    mixin = "notedge.idea.language.mixin.MixinSnippet"
}
math    ::= MATH_L string? MATH_R // $math$
// ---------------------------------------------------------------------------------------------------------------------
string  ::= (STRING_TEXT | ESCAPE_TEXT)+;
// ---------------------------------------------------------------------------------------------------------------------
xml_function ::= xml_start statement* xml_end
xml_closed   ::= ANGLE_L  namespace argument* ANGLE_SR  // <name.space arg kw=arg/>
xml_start    ::= ANGLE_L  namespace argument* ANGLE_R   // <name.space arg kw=arg>
xml_end      ::= ANGLE_SL namespace argument* ANGLE_R   // </name.space>
// ---------------------------------------------------------------------------------------------------------------------
// \name.space
function ::= ESCAPE namespace [args_function] [args_text|args_block] {
    mixin = "notedge.idea.language.mixin.MixinFunction"
}
args_function ::= <<parenthesis argument COMMA>>
args_text ::= COLON STRING_TEXT?
args_block ::= <<brace STRING_TEXT>>
argument ::= [key (EQ|COLON)] value
key ::= identifier
value ::= namespace | list
// ---------------------------------------------------------------------------------------------------------------------
list ::= <<bracket value COMMA>>
// ---------------------------------------------------------------------------------------------------------------------
identifier ::= SYMBOL
namespace ::= identifier (DOT identifier)*
// ---------------------------------------------------------------------------------------------------------------------
// parenthesis ( )
meta parenthesis ::= PARENTHESIS_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] PARENTHESIS_R;
// bracket [ ]
meta bracket ::= BRACKET_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] BRACKET_R;
// brace { }
meta brace ::= BRACE_L <<item>>* BRACE_R;

